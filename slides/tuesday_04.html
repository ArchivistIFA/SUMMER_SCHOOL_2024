




<!DOCTYPE html>
<html>
  <head>
    <title>Digital Summer School 2024: Tuesday Morning</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="../style.css">  </head>
  <body>
    <textarea id="source">

class: center, middle, titlepage
### TUE04: *Fixity and storage.*

---
class: contentpage
### **Agenda**


      
1. Intro to Hashing/Checksums (Paul)
2. Streamhashing, whole file hashing, types of checksum algorithms. (Jo)
3. Lossless framemd5 frame level checksums. (Jo)
4. FFV1 checksums at slice level. (Jo)
5. Python hashlib. (Paul)
6. Perceptual hashing, visual similarity matching. (Paul)
7. Bagit for Python. (Paul)
8. TAR wrapping with CLI 'tar' or Python 'tarfile'. (Paul)

      


---
class: contentpage

### **1. Intro to Hashing/Checksums**

What are hashes/checksums? The generally look something like this: b3f719581e88f269c558b18d3cdc2f72

"Fixed-width predictable digital fingerprints" - in digital archiving, a common way to reproduicbly assess if data has remained unchanged overtime.

Terminology "hashes" vs "checksums": hashes normally used for web security, checksums for file checking, but they are conceptually the same and the terms are generally used interchangeably.

For web security they are used to store passwords:

"my_cool_password" -> MD5 -> a873aee995ffc1fe2634e63560d3aabb

I can store the resulting hash in my system and don't know the users actual password, they can authenticate whenever they like, and if the system is hacked the attacker *still* won't know the user's password (assuming the hashing algoritjm it "cryptographically secure")

Checksums will be different as soon as the source data is different, although normally not proportinal to the amount of change ("perceptual hashing" being the exception)

"Paul Duchesne" -> MD5 -> 0396b497d1949e210d09692607734e97
"paul duchesne" -> MD5 -> 020a2e9d9693e62d76bc00f14a99a6a7

Use for digital preservation, where there is a strong concern around "has something changed in my file", although worth noting a key difference between the web security appliocation of hashes and the archivist: archivists geenrally assume that any changes will be accidental, whereas in the securirty space there is a presumption of bad actors.

Take for example a checksum collision, when two files produce the same hash: it is astornimilaclly unlikely that in a digital archive two different files could create the same hash, but in a security space there will be people who are very actively trying to create files with the same ahsh (to substitute documents, or logion to restricted systems).

total number of possible md5s is 340,282,366,920,938,463,463,374,607,431,768,211,456

however if you were to generate 18,446,744,073,709,551,616 hashes you would have a 50% chance of a collision due to 'the birthday paradox'









core concepts, one directional, examples passwords, metoo callouts

single bit changes, hash changes, normally not proportional to amount of change (exception percuptual)
eg "Paul Duchesne" == "paul duchesne"

use for digital preservation, has my file changed

different hashing algoritms, speed and length of result

md5 ubiquiouts, slow, not crypto secure, what does that mean

chance of colisions, birthday paradox, idnetional collision exploits

xxhash much faster but increased chance of collisions, tolerable?




---
class: contentpage

### **2. Streamhashing, whole file hashing, types of checksum algorithms**

---
class: contentpage

### **3. Lossless framemd5 frame level checksums**

---
class: contentpage

### **4. FFV1 checksums at slice level**

---
class: contentpage

### **5. Python hashlib**

We can generate hashes from the command line, but there are resons we will want to use in python, eg as part of a media processing script

couple of ways to do hashing, subprocess, hashlib.

Python has an inbuilt library called hashlib

examples of hashing a string

exampels of hashing a file

python example of hashing many files in a directory

---
class: contentpage

### **6. Perceptual hashing, visual similarity matching**

perceuptuial hashing has a different purpose, and worth introducing as a concept
while checksum hashing for file validation is ubiqisuot, hashing for content similarity is more unusal and only a few institutions are doing (eg?)

do in Python?

example similar strings return similar hashes

example simialr images return similar hashes

where would this be useful for an archive, similarity detection

say someone gives you digital material, it is useful to be able to check if it is already in your collection, but any slight change precludes you from checking

perceptual hashes allow to find where the is content overlap, even if the file itself is slightly different

---
class: contentpage

### **7. Bagit for Python**

BagIt is a solution designed to give you common structures and tools to work with these concepts and is typically used for collections of files.
developed by library of congress

You could write your own python scripts to create checksums and validate checksums, but bagit is just a conveniance method. to do a lot of great stuff 

bagit can run from the command line, 

otherwise loc bagit library - ASIDE, how to install a external library
up until now we have been looing at libraries which come bundled with python
but bagit is different, this is a python library written by library of congress.
pip install, pip freeze

amia grabbags for multiple files supporting

Practical: BagIt for film scan


---
class: contentpage

### **8. TAR wrapping with CLI 'tar' or Python 'tarfile'**

Great so we have our 'bag', what do we do with it?

generally speaking most archives will then wrap the bag - important point, bagit is not a filetype, it is a system.
most archives use TAR, which is a very very old (1979) and widely supported means of wrapping files.
similar to zip

as you have probably many times, we can eaither create tars from the command line on a unix-machine (linux/mac) or using python (os agnostic)

python has an inbuilt tarfile library

Practical: TAR wrap bagit

Practical: untar

Practical: validate fixity - swap frames, check process.


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ratio: "16:9"});
    </script>
  </body>
</html>
